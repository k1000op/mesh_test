<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nube de Puntos GLB - Vista con Perspectiva y Rotación</title>
    <style>
        /* Estilos básicos para que el canvas ocupe toda la ventana */
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: sans-serif;
            font-size: 1.5em;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading-message">Cargando modelo... (Asegúrate de que exista 'modelo.glb')</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // =========================================================
        // === CONFIGURACIÓN INICIAL ===
        // =========================================================
        const scene = new THREE.Scene();
        const container = document.body;
        const loadingMessage = document.getElementById('loading-message');
        
        // 1.1. Configuración de la Cámara: VISTA CON PERSPECTIVA
        const FOV = 6; // Ángulo de Visión (Field of View)
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.1;
        const far = 1000;

        // Se usa PerspectiveCamera para un renderizado 3D realista
        const camera = new THREE.PerspectiveCamera(FOV, aspect, near, far);

        // Posición de la cámara: Vista superior-diagonal para apreciar la perspectiva
        camera.position.set(0, 1, 0); 
        camera.lookAt(0, 0, 0); 
        // 
        
        // 1.2. Configuración del Renderizador
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        scene.background = new THREE.Color(0xffffff); 
        let pointCloud; 
        const GLB_PATH = 'taza02.glb'; // *** RUTA DE TU ARCHIVO GLB ***


        // =========================================================
        // === FUNCIÓN DE CONVERSIÓN A NUBE DE PUNTOS ===
        // =========================================================

        function createPointCloud(mesh) {
            const geometry = mesh.geometry;
            
            if (!geometry.attributes.position) {
                console.error("Geometría sin atributos de posición.");
                return null;
            }

            const pointGeometry = new THREE.BufferGeometry();
            const positions = geometry.attributes.position.array;
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Material para los puntos
            const pointMaterial = new THREE.PointsMaterial({
                color: 0x003166, // Color azul cian
                size: 0.00003,      // Ajusta el tamaño de los puntos
                sizeAttenuation: true // Hace que los puntos lejanos sean más pequeños
            });
            
            const points = new THREE.Points(pointGeometry, pointMaterial);

            // Centrar la nube de puntos en el origen (0, 0, 0)
            points.geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            points.geometry.boundingBox.getCenter(center);
            points.geometry.translate(-center.x, -center.y, -center.z);
            
            return points;
        }


        // =========================================================
        // === CARGA DEL ARCHIVO GLB ===
        // =========================================================

        const loader = new THREE.GLTFLoader();

        loader.load(
            GLB_PATH,
            function (gltf) {
                loadingMessage.style.display = 'none'; // Ocultar mensaje
                
                let mesh = null;
                gltf.scene.traverse(function (child) {
                    if (child.isMesh && !mesh) {
                        mesh = child;
                    }
                });

                if (mesh) {
                    pointCloud = createPointCloud(mesh);
                    if (pointCloud) {
                         scene.add(pointCloud);
                    }
                } else {
                    console.error("No se encontró ningún objeto Mesh en el archivo GLB.");
                }
            },
            // Función de progreso 
            function (xhr) {
                const percent = Math.round(xhr.loaded / xhr.total * 100);
                loadingMessage.textContent = `Cargando modelo: ${percent}%`;
            }, 
            // Función de error
            function (error) {
                loadingMessage.textContent = "Error al cargar el modelo. ¿Existe 'modelo.glb'?";
                console.error('Error al cargar el GLB:', error);
            }
        );


        // =========================================================
        // === BUCLE DE ANIMACIÓN (ROTACIÓN) ===
        // =========================================================

        function animate() {
            requestAnimationFrame(animate);

            if (pointCloud) {
                // Rotación suave alrededor del eje Y (vertical)
                pointCloud.rotation.y += 0.0008; 
            }

            renderer.render(scene, camera);
        }

        // Iniciar la animación
        animate();


        // =========================================================
        // === MANEJO DE REDIMENSIONAMIENTO (Actualizado para Perspectiva) ===
        // =========================================================

        function onWindowResize() {
            // Actualizar la relación de aspecto del renderizador
            camera.aspect = window.innerWidth / window.innerHeight;
            
            // Aplicar los cambios a la cámara
            camera.updateProjectionMatrix();

            // Actualizar el tamaño del renderizador
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

    </script>
</body>
</html>
